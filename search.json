[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Orbital Mechanics: Keplerian model",
    "section": "",
    "text": "Preface\nThis book aims to provide a comprehensive guide to the Keplerian model of orbital mechanics, covering the fundamental principles and equations governing the motion of celestial bodies. We will explore the historical context of orbital mechanics, starting with the work of Johannes Kepler and Isaac Newton, and progressing to model various systems such as the two body system and orbit maneuvers later on.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#current-chapters",
    "href": "index.html#current-chapters",
    "title": "Orbital Mechanics: Keplerian model",
    "section": "Current chapters",
    "text": "Current chapters\n\nChapter 1: Introduces Newton’s Laws of gravitation and an appreciation of the work behind the derivation of the law\nChapter 2: Derivation of equations of motion in a two-body problem, introduces us to eccentricity of orbit, and derives the orbit equation.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapter_01.html",
    "href": "chapter_01.html",
    "title": "1  Newton’s law of gravitation",
    "section": "",
    "text": "1.1 Kepler’s Laws of planetary motion\nNewton formulated that the gravitational force between two point masses is directly proportional to the product of their masses and inversely proportional to the square of the distance between them (which is known as the inverse square law).\n\\[\n|\\vec{F}| \\propto \\frac{m_1 m_2}{r^2}\n\\tag{1.1}\\]\nWhere: \\(\\vec{F}\\) is the force acting on one of the bodies from the other, \\(m_1, m_2\\) are the masses of the bodies and \\(\\vec r\\) is the vector from mass \\(m_1\\) to \\(m_2\\) whose magnitude is \\(r\\).\nWhile the equation is enough to know to contemplate rest of the Keplerian model of orbital mechanics, one might be curious as to how did Newton arrive at this formulation. We answer that in the following sections taking the case of planetary orbits around the Sun.\nKepler, building on Tycho Brahe’s detailed astronomical data, established these laws:\nNow we will see how each of the above laws helped Newton come to his conclusion.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Newton's law of gravitation</span>"
    ]
  },
  {
    "objectID": "chapter_01.html#keplers-laws-of-planetary-motion",
    "href": "chapter_01.html#keplers-laws-of-planetary-motion",
    "title": "1  Newton’s law of gravitation",
    "section": "",
    "text": "1st Law: Planets move in elliptical orbits with the Sun at one focus.\n2nd Law: The line joining a planet and the Sun sweeps out equal areas in equal time.\n3rd Law: The square of a planet’s orbital period is proportional to the cube of its semi-major axis.\n\\[\nT^2\\propto a^3\n\\tag{1.2}\\]\nWhere \\(T\\) is the time period and \\(a\\) is the semi-major axis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Newton's law of gravitation</span>"
    ]
  },
  {
    "objectID": "chapter_01.html#area-law-implying-central-force",
    "href": "chapter_01.html#area-law-implying-central-force",
    "title": "1  Newton’s law of gravitation",
    "section": "1.2 Area Law implying central force",
    "text": "1.2 Area Law implying central force\nNewton inferred that the force must be a central force—pointing toward the Sun—because Kepler’s Second Law (the area law) states that a planet sweeps out equal areas in equal time. The following derivation will make it clear as to how.\nWe know,\n\\[\n\\frac{dA}{dt}=K\n\\]\nwhere \\(K\\) is a constant.\n\n\n\nDifferential area dA swept out by the relative position vector \\(\\vec{r}\\) during time interval dt. (Fig. 2.9 Curtis 2005)\n\n\nHere \\(m_1\\) is the Sun and \\(m_2\\) is the planet.\nUsing the formula for area of triangle on the infinitesimal area dA, we get\n\\[\ndA=\\frac{1}{2}\\times vdt\\times r\\sin{\\phi}\n\\]\n\\[\n\\Rightarrow dA=\\frac{1}{2} r(v \\sin{\\phi}) dt= \\frac{1}{2} rv_{\\perp} dt\n\\]\nWe know that \\(\\vec{h}=rv_{\\perp} \\hat{h}\\) , where \\(\\vec{h}\\) is the specific relative angular momentum of \\(m_2\\) wrt \\(m_1\\).\n\n\n\n\n\n\nNote\n\n\n\nAngular momentum is defined as: \\[      \\vec{H}=\\vec{r}\\times (m\\vec{v})  \\] \\[     \\vec{h}=\\vec{r}\\times \\vec{v}=rv\\sin{\\phi} \\hat{h} \\] where \\(\\phi\\) is the angle between the position vector \\(\\vec{r}\\) and the velocity vector \\(\\vec{v}\\), and \\(\\hat{h}=\\hat{r}\\times \\hat{v}\\) is the unit vector perpendicular to the plane of motion.\n\n\n\\[\n\\boxed{\\frac{dA}{dt}=\\frac{h}{2}=K}\n\\tag{1.3}\\]\nThe angular momentum of \\(m_2\\) wrt \\(m_1\\) turns out to be a constant. This only happens if the torque about the Sun is zero, which in turn implies that the force has no component perpendicular to the radius vector. Therefore, the force must always point along the line joining the planet and the Sun, making it a central force.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Newton's law of gravitation</span>"
    ]
  },
  {
    "objectID": "chapter_01.html#derivation-of-the-inverse-square-relationship",
    "href": "chapter_01.html#derivation-of-the-inverse-square-relationship",
    "title": "1  Newton’s law of gravitation",
    "section": "1.3 Derivation of the inverse-square relationship",
    "text": "1.3 Derivation of the inverse-square relationship\nWe now work in polar coordinates for ease of derivation. For a particle moving under a central force:\n\\[\n\\vec{F} =m\\vec a= m(\\ddot{r} - r \\dot{\\theta}^2) \\hat{r} + m(r \\ddot{\\theta} + 2\\dot{r}\\dot{\\theta}) \\hat{\\theta}\\qquad\\text{(Newton's 2nd law)}\n\\]\n\n\n\n\n\n\nKey identities (time derivatives of unit vectors)\n\n\n\n\\[\n\\frac{d\\hat r}{dt}=\\dot\\theta\\,\\hat\\theta,\\qquad\n\\frac{d\\hat\\theta}{dt}=-\\dot\\theta\\,\\hat r,\n\\tag{1.4}\\] following directly from differentiating the explicit Cartesian definitions of the unit vectors: \\[\n\\hat r = \\cos\\theta\\,\\hat\\imath + \\sin\\theta\\,\\hat\\jmath,\\qquad\n\\hat\\theta = -\\sin\\theta\\,\\hat\\imath + \\cos\\theta\\,\\hat\\jmath.\n\\]\nUsing Equation 1.4, we can compute \\(\\ddot{\\vec r}\\) doing the following: \\[\n\\vec v=\\dot{\\vec r}=\\frac{d}{dt} (r\\hat r)\n\\]\nWhich gives,\n\\[\n\\vec v= \\dot r\\hat r+r\\dot{\\theta}\\hat \\theta\n\\tag{1.5}\\]\nAnd, \\[\n\\vec a=\\dot{\\vec v}\n\\]\ngives the above formulation of acceleration\n\n\n\nThe \\(\\hat{\\theta}\\)-component is zero (since force is radial) such that angular momentum is conserved.\nThe radial equation simplifies to:\n\\[\nm\\left( \\ddot{r} - r \\dot{\\theta}^2 \\right) = F(r)\n\\tag{1.6}\\]\n\nNow, from Kepler’s first law, we see that the orbit must be an ellipse with the Sun at one focus. Hence, the equation\n\\[ r(\\theta)=\\frac{p}{1+e\\cos{\\theta}}  \\tag{1.7}\\]\nholds. Here \\(p\\) is the semi latus-rectum, \\(e\\) is the eccentricity of the ellipse orbit and \\(\\theta\\) is the angle between the line joining the focus to the point and line joining focus to the periapsis.\nWe get a new variable \\(u\\) where:\n\\[\nu=\\frac{1}{r}\n\\]\nThen,\n\\[\n\\frac{dr}{d\\theta}=-\\frac{1}{u^2}\\frac{du}{d\\theta}\n\\]\n\n\n\n\n\n\nNote\n\n\n\nWe know that specific angular momentum \\((\\vec h)\\) is\n\\[ \\vec h= \\vec r \\times \\vec v \\]\nFrom \\(\\vec r=r\\hat r\\) and \\(\\vec v= \\dot r\\hat r+r\\dot{\\theta}\\hat \\theta\\):\n\\[ \\vec h= \\vec r \\times \\vec v = r\\hat r \\times \\left(\\dot r\\hat r+r\\dot{\\theta}\\hat \\theta\\right) = r^2\\dot{\\theta}\\hat h \\]\nWhere \\(\\hat h = \\hat r \\times \\hat \\theta\\) is the unit vector perpendicular to the plane of motion. Implying,\n\\[ h=r^2\\dot \\theta \\]\n\n\n\\[\n\\dot r=\\frac{dr}{dt}=\\frac{dr}{d\\theta}\\frac{d\\theta}{dt}=-\\frac{1}{u^2}\\frac{du}{d\\theta}hu^2\n\\]\n\\[\n\\boxed{\\dot r=-h\\frac{du}{d\\theta}}\n\\]\nDifferentiating the above wrt \\(t\\):\n\\[\n\\ddot r=-h\\frac{d}{dt}\\left(\\frac{du}{d\\theta}\\right)=-h\\dot \\theta\\frac{d^2u}{d\\theta^2}\n\\]\nAgain we substitute \\(\\dot \\theta=hu^2\\) onto the above equation.\n\\[\n\\ddot r=-h^2u^2\\frac{d^2u}{d\\theta^2}\n\\tag{1.8}\\]\nSubstituting Equation 1.8 and \\(\\dot \\theta=hu^2\\) onto Equation 1.6 :\n\\[\n-h^2 u^2 \\frac{d^2 u}{d\\theta^2} - \\frac{1}{u} \\cdot h^2 u^4 = \\frac{F(r)}{m}\n\\] Simplify: \\[\n-h^2 u^2 \\frac{d^2 u}{d\\theta^2} - h^2 u^3 = \\frac{F(1/u)}{m}\n\\]\nMultiply both sides by \\(-\\frac{1}{h^2 u^2}\\):\n\\[\n\\frac{d^2 u}{d\\theta^2} + u = -\\frac{F(1/u)}{m h^2 u^2}\n\\tag{1.9}\\]\nNow, substituting \\(u=\\frac{1}{r}\\) onto Equation 1.7 gives:\n\\[\nu=\\frac{1}{p}+\\frac{e}{p} \\cos{\\theta}\n\\]\n\\[\n\\Rightarrow \\frac{du}{d\\theta}=-\\frac{e}{p}\\sin \\theta\\quad\\text{and}\\quad\\frac{d^2u}{d\\theta^2}=-\\frac{e}{p}\\cos \\theta\n\\]\nUsing the above on Equation 1.9 we get:\n\\[\n\\frac{1}{p}+\\frac{e}{p} \\cos{\\theta}-\\frac{e}{p} \\cos{\\theta}=-\\frac{F(1/u)}{m h^2 u^2}\n\\]\nAnd putting back \\(u=\\frac{1}{r}\\),\n\\[\n\\vec F(r)=-\\frac{mh^2}{pr^2}\n\\]\n\\[\n\\Rightarrow \\vec F \\propto \\frac{1}{r^2}\n\\]\nThis showed Newton that the acceleration required to keep a planet in orbit must follow an inverse-square law.\nTo test the universality of this law, Newton compared the gravitational acceleration near Earth’s surface ( \\(a_E\\approx 9.81 m/s^2\\)) with the centripetal acceleration needed to keep the Moon in its orbit using the following measurements to calculate the velocity in its orbit:\n\nThe Moon’s distance from the Earth: (calculated using parallax method) about 60 Earth radii (or 384,400 km).\n\n\n\n\n\n\nParallax Method\n\n\n\nThe parallax method determines the Moon’s distance by observing its apparent shift against background stars from two distant points on Earth. This angular difference, called the parallax angle (p), relates to the distance(\\(D\\)) by:\n\\[\nD=\\frac{R_E}{\\sin{p}}\n\\]\nWhere \\(R_E\\) is the radius of the Earth (see below).\n\n\n\n\n\n\n\n\nDetermination of Earth’s Radius\n\n\n\nThe Earth’s radius was first scientifically estimated by Eratosthenes (~240 BCE), who used the difference in the Sun’s angle between Syene and Alexandria at noon on the summer solstice. By measuring this angular difference (~7.2°) and knowing the distance between the two cities, he calculated Earth’s circumference to be about 40,000 km, yielding a radius of approximately 6,370 km.\nBy Newton’s time, more precise measurements came from land-based triangulation. In the 1670s, Jean Picard used observations of a meridian arc near Paris to estimate Earth’s radius as 6,328 km, which Newton used in his gravitational calculations.\n\n\nAnd its orbital period was around 27.3 days.\n\nAnd he found:\n\\[\\frac{a_E}{a_M}\\approx \\left(\\frac{r_M}{r_E}\\right)^2\n\\] where \\(a_E\\) is the acceleration of an object on Earth, \\(a_M\\) the acceleration of the moon due to Earth, \\(r_M\\) the distance of the Moon from the center of the Earth and \\(r_E\\) the radius of Earth which is distance of the object on Earth from the center of the Earth. This confirmed that the same law governed both falling of objects near Earth as well as orbiting moons.\n\n\n\n\n\nCurtis, H. D. 2005. Orbital Mechanics: For Engineering Students. Aerospace Engineering. Elsevier Science. https://books.google.co.in/books?id=nEO7lAEACAAJ.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Newton's law of gravitation</span>"
    ]
  },
  {
    "objectID": "chapter_02.html",
    "href": "chapter_02.html",
    "title": "2  Two Body Problem",
    "section": "",
    "text": "2.1 Equations of Motion for the Two body problem\nLet \\(\\vec{R}_1\\) and \\(\\vec{R}_2\\) denote the position vectors of masses \\(m_1\\) and \\(m_2\\) in an inertial reference frame. According to Newton’s Second Law and the law of gravitation:\n\\[\nm_1\\ddot{\\vec{R}}_1=-G\\frac{m_1 m_2}{r^3} \\vec{r}\n\\tag{2.1}\\]\n\\[\nm_2\\ddot{\\vec{R}}_2=G\\frac{m_1 m_2}{r^3} \\vec{r}\n\\tag{2.2}\\]\nwhere \\(\\vec{r}= \\vec{R}_2-\\vec{R}_1\\) the relative position vector between the two masses.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Two Body Problem</span>"
    ]
  },
  {
    "objectID": "chapter_02.html#equations-of-motion-for-the-two-body-problem",
    "href": "chapter_02.html#equations-of-motion-for-the-two-body-problem",
    "title": "2  Two Body Problem",
    "section": "",
    "text": "Diagram of two masses in an inertial frame OXYZ (Fig.2.1(a) Curtis (2005))\n\n\n\n2.1.1 Derivation of the relative equation of motion\nSubstituting Equation 2.1 and Equation 2.2 to \\(\\vec{r}= \\vec{R}_2-\\vec{R}_1\\):\n\\(\\ddot{\\vec{r}}= -G\\frac{m_1 m_2}{r^3}\\vec{r}\\left(\\frac{1}{m_2}+\\frac{1}{m_1}\\right)= -G \\frac{m_1+m_2}{r^3} \\vec{r}\\)\nLet the gravitational 𝜇 parameter be defined as:\n\\[\n\\mu= G(m_1+m_2)\n\\]\nHence the final equation that we use turns out to be:\n\\[\n\\boxed{\\ddot{\\vec{r}}=-\\frac{\\mu}{r^3}\\vec{r}}\n\\tag{2.3}\\]\n\n\n2.1.2 Motion of Center of Mass\nThe center of mass vector is: \\(\\vec{R}_G=\\frac{m_1\\vec{R}_1+m_2\\vec{R}_2}{m_1+m_2}\\)\nUsing Equation 2.1 and Equation 2.2 :\n\\[\n\\ddot{\\vec{R}}_G= \\frac{m_1\\ddot{\\vec{R}}_1+m_2\\ddot{\\vec{R}}_2}{m_1+m_2}\n\\tag{2.4}\\]\n\\[\n\\ddot{\\vec{R}}_G=\\frac{-G\\frac{m_1m_2}{r^3}\\vec{r}+G\\frac{m_1m_2}{r^3}\\vec{r}}{m_1+m_2}=0\n\\]\nHence proved that the acceleration of center of mass is zero.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Two Body Problem</span>"
    ]
  },
  {
    "objectID": "chapter_02.html#sec-angularmom",
    "href": "chapter_02.html#sec-angularmom",
    "title": "2  Two Body Problem",
    "section": "2.2 Angular momentum in two body problem",
    "text": "2.2 Angular momentum in two body problem\nThe angular momentum of body \\(m_2\\) relative to \\(m_1\\) is moment of \\(m_2\\)’s relative linear momentum \\(m_2 \\dot{\\vec{r}}\\):\n\\[\n\\vec{H}_{2/1}= \\vec{r} \\times m_2\\dot{\\vec{r}}\n\\]\nwhere \\(\\dot{\\vec{r}}\\) is the velocity of \\(m_2\\) relative to \\(m_1\\). We divide this equation of the mass term and get the specific relative angular momentum:\n\\[\n\\vec{h}= \\vec{r}\\times\\dot{\\vec{r}}\n\\]\nOn calculating the time derivative:\n\\[\n\\frac{d\\vec{h}}{dt}=\\underbrace{\\dot{\\vec{r}}\\times\\dot{\\vec{r}}}_{0}+ \\vec{r}\\times \\ddot{\\vec{r}}\n\\]\nFrom the Equation 2.3, we see that \\(\\ddot{\\vec{r}} \\parallel \\vec{r}\\) . Hence \\(\\frac{d\\vec{h}}{dt}=0 \\Rightarrow \\vec{h}\\) is conserved.\n\n2.2.1 Eccentricity of orbit from Laplace-Runge-Lenz vector\nDifferentiating \\(\\dot {\\vec r} \\times \\vec h\\):\n\\[\n\\frac{d}{dt}(\\dot{\\vec r}\\times\\vec h)= \\ddot{\\vec r}\\times\\vec h + \\dot{\\vec r}\\times\\underbrace{\\dot{\\vec h}}_{0}= -\\frac{\\mu}{r^{3}}\\vec r\\times(\\vec r\\times\\dot{\\vec r})\n\\tag{2.5}\\]\nUsing the triple product identity \\(\\vec{a}\\times(\\vec{b}\\times\\vec{c})=(\\vec{a}\\cdot\\vec{c})\\vec b-(\\vec a \\cdot \\vec b)\\vec c\\) :\n\\[\n\\vec r\\times(\\vec r\\times\\dot{\\vec r})= (\\vec r\\cdot\\dot{\\vec r})\\vec r - r^{2}\\dot{\\vec r}\n\\]\nAnd using the identity \\(\\vec r \\cdot \\dot{\\vec r}=r\\dot r\\), we get:\n\\[  \\vec r\\times(\\vec r\\times\\dot{\\vec r})= (r\\dot r)\\vec r - r^{2}\\dot{\\vec r}   \\tag{2.6}\\]\n\n\n\n\n\n\n\\(\\vec r \\cdot \\dot{\\vec r}=r\\dot r\\)\n\n\n\nWe know that:\\[\\vec r \\cdot\\vec r=r^2\\]\nThen:\\[\\frac{d}{dt}(\\vec r\\cdot \\vec r)=2r\\frac{dr}{dt}=2r\\dot r\n\\]\nBut,\\[\\frac{d}{dt}(\\vec r \\cdot \\vec r)=\\vec r\\cdot \\frac{d\\vec r}{dt}+\\frac{d\\vec r}{dt}\\cdot \\vec r=2\\vec r\\cdot \\frac{d\\vec r}{dt}=2\\vec r\\cdot \\dot{\\vec r}\\]\nHence:\\[\n\\boxed{\\vec r\\cdot\\dot{\\vec r}=r\\dot r}\n\\]\n\n\nInserting Equation 2.6 into Equation 2.5 :\n\\[\n\\frac{d}{dt}(\\dot{\\vec r}\\times \\vec h)=- \\frac{\\mu}{r^3}\\left[(r \\dot{r})\\vec r - r^2 \\dot{\\vec r}\\right]=-\\mu \\left[\\frac{\\dot r \\vec r-r\\dot{\\vec{r}}}{r^2}\\right]\n\\tag{2.7}\\]\nBut ,\n\\[\n\\frac{d}{dt}\\left(\\frac{\\vec r}{r}\\right)= \\frac{r\\dot{\\vec r}-\\dot r\\vec r}{r^2}=-\\frac{\\dot r\\vec r-r\\dot{\\vec{r}}}{r^2}\n\\]\nsubstituting the above into Equation 2.7;\n\\[\n\\frac{d}{dt}\\left(\\dot{\\vec r}\\times \\vec h\\right)= \\frac{d}{dt}\\left(\\mu\\frac{\\vec r}{r}\\right)\n\\]\nWhich on integration, gives this solution:\n\\[\n\\frac{1}{\\mu}(\\dot{\\vec{r}}\\times \\vec h)-\\frac{\\vec r}{r}=\\vec e\n\\tag{2.8}\\]\nwhere \\(\\vec e\\) is the constant of integration and called as the Laplace-Runge-Lenz Vector. The significance of this vector is that its magnitude \\(|\\vec e|\\) gives the eccentricity \\(e\\) and it faces in the direction of the periapsis of the orbit.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Two Body Problem</span>"
    ]
  },
  {
    "objectID": "chapter_02.html#orbit-equation-trajectory-under-gravity",
    "href": "chapter_02.html#orbit-equation-trajectory-under-gravity",
    "title": "2  Two Body Problem",
    "section": "2.3 Orbit Equation (Trajectory Under Gravity)",
    "text": "2.3 Orbit Equation (Trajectory Under Gravity)\nEquation 2.8 is the vector equation that represents the orbit of one of the bodies wrt the other in the two body problem. In order to obtain the scalar form, we take a dot product with \\(\\vec r\\):\n\\[\n\\frac{1}{\\mu}(\\dot{\\vec{r}}\\times \\vec h)\\cdot \\vec r-\\frac{\\vec r\\cdot \\vec r}{r}=\\vec e\\cdot \\vec r\n\\]\nUsing the identity \\(\\vec a \\cdot (\\vec b \\times \\vec c)=(\\vec a \\times \\vec b)\\cdot \\vec c\\);\n\\[\n\\frac{1}{\\mu}\\underbrace{(\\vec r \\times \\dot{\\vec r})}_{\\vec h}\\cdot \\vec h- \\frac{\\vec r\\cdot\\vec r}{r}=\\vec e\\cdot\\vec r\n\\]\n\\[\n\\frac{h^2}{\\mu}-r=re\\cos{\\theta} \\text{ where } \\theta \\text{ is the true anomaly angle }\n\\]\n\n\n\nThe true anomaly \\(\\theta\\) is the angle between the eccentricity vector \\(\\vec{e}\\) and the position vector \\(\\vec{r}\\) (See Fig. 2.10 Curtis (2005))\n\n\nHence the final equation of orbit will turn out to be as follows:\n\\[\n\\boxed{r=\\frac{\\frac{h^2}{\\mu}}{1+e\\cos{\\theta}}}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Two Body Problem</span>"
    ]
  },
  {
    "objectID": "chapter_02.html#two-body-problem-simulation",
    "href": "chapter_02.html#two-body-problem-simulation",
    "title": "2  Two Body Problem",
    "section": "2.4 Two body problem simulation",
    "text": "2.4 Two body problem simulation\nBelow is a simulation of the two body problem with an example: a binary star system of two Suns whose masses are equal.\n\n\nClick to view the code\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D   # noqa: F401 (needed for 3-D plots)\nfrom matplotlib.animation import FuncAnimation, FFMpegWriter#, PillowWriter # (optional, for GIFs)\nimport os\n# --------------------  physical constants  --------------------\nG = 6.67430e-11      # SI [m^3 kg^-1 s^-2]\n\n# --------------------  helper functions  ----------------------\ndef orbital_velocity(mu, r, a=None, e=0.0):\n    \"\"\"\n    Magnitude of the relative velocity for the chosen orbit.\n    mu = G*(m1+m2)\n    r  = current separation\n    a  = semi-major axis (None -&gt; circular orbit with radius r)\n    e  = eccentricity\n    Returns scalar speed v.\n    \"\"\"\n    if a is None:          # circular orbit\n        a = r\n    return np.sqrt(mu * (2.0/r - 1.0/a))\n\ndef set_initial_conditions(m1, m2, r_periapsis, e=0.0, inclination=0.0,omega=0.0, Omega=0.0, random_phase=False):\n    \"\"\"\n    Build the 12-component state vector\n    [r1, v1, r2, v2] consistent with the desired relative orbit.\n\n    All angles in radians.\n    Returns y0 = [x1,y,z1, vx1,vy1,vz1, x2,y2,z2, vx2,vy2,vz2]\n    \"\"\"\n    mu = G*(m1 + m2)\n\n    # Relative orbit: choose the periapsis along the x-axis\n    r_rel = np.array([r_periapsis, 0.0, 0.0])\n    v_rel_mag = orbital_velocity(mu, r_periapsis,a=r_periapsis/(1.0 - e), e=e)\n\n    # Rotate by argument of periapsis (ω) in orbital plane\n    cosw, sinw = np.cos(omega), np.sin(omega)\n    rot_z = np.array([[cosw, -sinw, 0],[sinw,  cosw, 0],[0,     0,    1]])\n    r_rel = rot_z @ r_rel\n    v_rel = rot_z @ np.array([0.0, v_rel_mag, 0.0])\n\n    # Inclination & line-of-nodes rotation\n    cosi, sini = np.cos(inclination), np.sin(inclination)\n    cosO, sinO = np.cos(Omega), np.sin(Omega)\n\n    rot_inc = np.array([[1, 0,      0],\n                        [0, cosi,  -sini],\n                        [0, sini,   cosi]])\n    rot_O   = np.array([[cosO, -sinO, 0],\n                        [sinO,  cosO, 0],\n                        [0,     0,    1]])\n    r_rel = rot_O @ rot_inc @ r_rel\n    v_rel = rot_O @ rot_inc @ v_rel\n\n    # Centre of mass at origin and zero total momentum\n    M = m1 + m2\n    r1 = -(m2/M) * r_rel\n    r2 =  (m1/M) * r_rel\n    v1 = -(m2/M) * v_rel\n    v2 =  (m1/M) * v_rel\n\n    y0 = np.concatenate((r1, v1, r2, v2))\n    return y0\n\n# --------------------  integrator  ----------------------------\ndef rhs(t, y, m1, m2):\n    \"\"\"\n    Derivatives for the 12-D state vector y.\n    Uses simple Newtonian gravity.\n    \"\"\"\n    r1 = y[:3]\n    r2 = y[6:9]\n    dr = r2 - r1\n    dist3 = np.linalg.norm(dr)**3\n    a1 =  G * m2 * dr / dist3\n    a2 = -G * m1 * dr / dist3\n    dydt = np.empty_like(y)\n    dydt[:3]  = y[3:6]      # v1\n    dydt[3:6]  = a1\n    dydt[6:9]  = y[9:12]     # v2\n    dydt[9:12] = a2\n    return dydt\n\ndef rk4_step(f, t, y, h, *args):\n    k1 = f(t, y, *args)\n    k2 = f(t + 0.5*h, y + 0.5*h*k1, *args)\n    k3 = f(t + 0.5*h, y + 0.5*h*k2, *args)\n    k4 = f(t + h, y + h*k3, *args)\n    return y + (h/6.0)*(k1 + 2*k2 + 2*k3 + k4)\n\ndef simulate_two_body_orbit(m1, m2,\n                            r_periapsis,\n                            e=0.0,\n                            inclination=0.0,\n                            Omega=0.0,\n                            omega=0.0,\n                            t_end=None,\n                            dt=None,\n                            frames=2000):\n    \"\"\"\n    Main user-facing routine.\n    m1, m2 in kg\n    r_periapsis in m\n    e, inclination, Omega, omega in radians\n    t_end : total integration time (s)  (None -&gt; 2 orbits)\n    dt    : step size (s)               (None -&gt; adaptive)\n    frames: number of output samples\n    Returns dict with numpy arrays: t, r1, r2\n    \"\"\"\n    y0 = set_initial_conditions(m1, m2, r_periapsis, e,\n                                inclination, omega, Omega)\n\n    # Estimate period for circular orbit (Kepler)\n    a = r_periapsis/(1.0 - e)\n    P = 2*np.pi*np.sqrt(a**3 / (G*(m1 + m2)))\n\n    if t_end is None:\n        t_end = 2*P\n    if dt is None:\n        dt = P/5000.0\n\n    t = 0.0\n    y = y0.copy()\n    times, traj1, traj2 = [t], [y[:3]], [y[6:9]]\n\n    steps = int(np.ceil(t_end/dt))\n    for _ in range(steps):\n        if t + dt &gt; t_end:\n            dt = t_end - t\n        y = rk4_step(rhs, t, y, dt, m1, m2)\n        t += dt\n        times.append(t)\n        traj1.append(y[:3])\n        traj2.append(y[6:9])\n\n    return dict(t=np.array(times),\n                r1=np.array(traj1),\n                r2=np.array(traj2))\n\n# --------------------  main program  ---------------------------\n# -----------------------------------------------------------\n#  Example: equal-mass binary (two Sun-like stars)\n# -----------------------------------------------------------\nif __name__ == \"__main__\":\n    # 1) Choose the system ----------------------------------------------------\n    m1 = 1.0e30            # 0.5 M☉ each (feel free to tweak)\n    m2 = 1.0e30\n    a    = 1.0e11          # semi-major axis = 0.67 AU → period ≈ 200 days\n    ecc  = 0.4             # eccentric orbit just to make it interesting\n    r_peri = a * (1 - ecc)\n\n    inc   = 20.0 * np.pi/180   # 20° inclination\n    Omega = 0.0\n    omega = 0.0\n\n    # integrate 2 full periods so we see several loops\n    mu = G*(m1 + m2)\n    P  = 2*np.pi * np.sqrt(a**3 / mu) # time period\n    t_end = 2*P\n    data = simulate_two_body_orbit(m1, m2,\n                                   r_periapsis=r_peri,\n                                   e=ecc,\n                                   inclination=inc,\n                                   Omega=Omega,\n                                   omega=omega,\n                                   t_end=t_end,\n                                   frames=600)\n\n    t  = data['t'] # time array\n    r1 = data['r1'] # position of body 1\n    r2 = data['r2'] # position of body 2\n    r_rel = r2 - r1  # relative position vector\n\n\n    # 2) 3-D figure (unchanged) ----------------------------------------------\n    fig = plt.figure(figsize=(7, 6))\n    ax  = fig.add_subplot(111, projection='3d')\n\n    lim = 1.05 * np.abs(r1).max()\n    ax.set_xlim(-lim, lim)\n    ax.set_ylim(-lim, lim)\n    ax.set_zlim(-lim, lim)\n    ax.set_xlabel('x [m]')\n    ax.set_ylabel('y [m]')\n    ax.set_zlabel('z [m]')\n    ax.set_title(r'Equal-mass binary ($m_1 = m_2 = 1\\times10^{30}\\,$kg)')\n\n    ax.plot([0], [0], [0], 'k+', markersize=8)\n\n    body1,  = ax.plot([], [], [], 'o', color='tab:red',   markersize=7, label='Star 1')\n    body2,  = ax.plot([], [], [], 'o', color='tab:green', markersize=7, label='Star 2')\n    trail1, = ax.plot([], [], [], '-', color='tab:red',   alpha=0.4, lw=1)\n    trail2, = ax.plot([], [], [], '-', color='tab:green', alpha=0.4, lw=1)\n    ax.legend()\n\n    max_trail = 300\n\n    # 3) Animation callbacks (same as before) ---------------------------------\n    def init():\n        body1.set_data([], [])\n        body1.set_3d_properties([])\n        body2.set_data([], [])\n        body2.set_3d_properties([])\n        trail1.set_data([], [])\n        trail1.set_3d_properties([])\n        trail2.set_data([], [])\n        trail2.set_3d_properties([])\n        return (body1, body2, trail1, trail2)\n\n    def update(frame):\n        body1.set_data([r1[frame, 0]], [r1[frame, 1]])\n        body1.set_3d_properties([r1[frame, 2]])\n        body2.set_data([r2[frame, 0]], [r2[frame, 1]])\n        body2.set_3d_properties([r2[frame, 2]])\n\n        start = 0\n        trail1.set_data(r1[start:frame, 0], r1[start:frame, 1])\n        trail1.set_3d_properties(r1[start:frame, 2])\n        trail2.set_data(r2[start:frame, 0], r2[start:frame, 1])\n        trail2.set_3d_properties(r2[start:frame, 2])\n\n        return (body1, body2, trail1, trail2)\n\n    # -----------------------------------------------------------\n    #  Optional 3-D GIF of the relative orbit ------------------\n    #  (body 2 as seen from body 1) -----------------------------\n    # -----------------------------------------------------------\n    fig3 = plt.figure(figsize=(6,5))\n    ax3  = fig3.add_subplot(111, projection='3d')\n    lim  = 1.05*np.abs(r_rel).max()\n    ax3.set_xlim(-lim, lim)\n    ax3.set_ylim(-lim, lim)\n    ax3.set_zlim(-lim, lim)\n    ax3.set_xlabel('x [m]')\n    ax3.set_ylabel('y [m]')\n    ax3.set_zlabel('z [m]')\n    ax3.set_title('Body 2 as seen from Body 1')\n\n    # body-1 (fixed)\n    body1_rel, = ax3.plot([0], [0], [0], 'o', color='gold', markersize=7, label='body-1')\n    rel_pt,  = ax3.plot([], [], [], 'o', color='tab:orange', markersize=7, label='body-2')\n    rel_trail, = ax3.plot([], [], [], '-', color='tab:orange', lw=1, alpha=0.5)\n    ax3.legend()\n\n    def init_rel():\n        rel_pt.set_data([], [])\n        rel_pt.set_3d_properties([])\n        rel_trail.set_data([], [])\n        rel_trail.set_3d_properties([])\n        return (body1_rel,rel_pt, rel_trail)\n\n    def update_rel(frame):\n        rel_pt.set_data([r_rel[frame, 0]], [r_rel[frame, 1]])\n        rel_pt.set_3d_properties([r_rel[frame, 2]])\n        start = 0\n        rel_trail.set_data(r_rel[start:frame, 0], r_rel[start:frame, 1])\n        rel_trail.set_3d_properties(r_rel[start:frame, 2])\n        return (body1_rel, rel_pt, rel_trail)\n\n\n    # 4) Build 3-D video file in inertial frame --------------------------------------------------------\n    ani = FuncAnimation(fig, update,\n                        frames=len(t),\n                        init_func=init,\n                        blit=True,\n                        interval=1000/ 240)\n\n    \n    outfile = \"binary_3d.mp4\"\n    ani.save(outfile, writer=FFMpegWriter(fps=240))\n    print(f\"Saved equal-mass binary animation → {os.path.abspath(outfile)}\")\n    \n    # 5) Build 3-D video file in relative frame --------------------------------------------------------\n    ani_rel = FuncAnimation(fig3, update_rel,\n                            frames=len(t),  \n                            init_func=init_rel,\n                            blit=True,  \n                            interval=1000/ 240) \n    outfile_rel = \"binary_rel_3d.mp4\"\n    ani_rel.save(outfile_rel, writer=FFMpegWriter(fps=240))\n    print(f\"Saved relative orbit animation → {os.path.abspath(outfile_rel)}\")\nThe output will be a video that shows the following:\n\n\n\n\n\n\nInertial reference frame\n\n\n\n\n\n\nRelative reference frame\n\n\n\n\n\n\n\n\n\n\nCurtis, H. D. 2005. Orbital Mechanics: For Engineering Students. Aerospace Engineering. Elsevier Science. https://books.google.co.in/books?id=nEO7lAEACAAJ.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Two Body Problem</span>"
    ]
  },
  {
    "objectID": "appendix.html",
    "href": "appendix.html",
    "title": "Appendix",
    "section": "",
    "text": "Table of equations",
    "crumbs": [
      "Appendix"
    ]
  },
  {
    "objectID": "appendix.html#table-of-equations",
    "href": "appendix.html#table-of-equations",
    "title": "Appendix",
    "section": "",
    "text": "Quantity\nEquation\n\n\n\n\nEllipse\n\\(r=\\dfrac{p}{1+e\\cos\\theta}\\)\n\n\nArea law\n\\(\\dot A=\\frac12 r^{2}\\dot\\theta =\\frac{h}{2}= \\text{const}\\)\n\n\nHarmonic law\n\\(T^{2}\\propto a^{3}\\)\n\n\nGravity\n\\(\\vec F_{21} = -\\dfrac{Gm_{1}m_{2}}{r^{2}}\\hat{u_r}\\)\n\n\nReduced EoM\n\\(\\ddot{\\vec r}=-\\dfrac{\\mu}{r^{3}}\\vec r\\)\n\n\nSpecific angular momentum\n\\(\\vec h=\\vec r\\times\\dot{\\vec r}\\)\n\n\nLaplace–Runge–Lenz vector\n\\(\\vec e=\\dfrac{\\dot{\\vec r}\\times\\vec h}{\\mu}-\\dfrac{\\vec r}{r}\\)",
    "crumbs": [
      "Appendix"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Curtis, H. D. 2005. Orbital Mechanics: For Engineering\nStudents. Aerospace Engineering. Elsevier Science. https://books.google.co.in/books?id=nEO7lAEACAAJ.",
    "crumbs": [
      "References"
    ]
  }
]